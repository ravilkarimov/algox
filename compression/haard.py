import numpy as np


### Пример, случай для 2х2
A = np.array([
    [188, 174, 165, 174],
    [192, 179, 169, 182],
    [210, 181, 169, 189],
    [198, 182, 180, 194]
])

A = np.array([
    [10, 15, 9, 8],
    [7, 14, 5, 0],
    [3, 56, 3, 12],
    [7, 20, 1, 6],
])

factor = 2
factor = np.sqrt(2)
W1 = np.array([
    [1, 0,  1,  0],
    [1, 0, -1,  0],
    [0, 1,  0,  1],
    [0, 1,  0, -1]]) / factor

W2 = np.array([
    [1,  1, 0, 0],
    [1, -1, 0, 0],
    [0,  0, factor, 0],
    [0,  0, 0, factor],
]) / factor

H = W2.T @ W1.T @ A @ W1 @ W2
A_back = W1 @ W2 @ H @ W2.T @ W1.T
assert np.allclose(A, A_back)

### Общий случай

def haar_matrix(n):
    """
    Рекурсивно строит ортогональную матрицу Хаара размером n x n, где n=2^k.
    """
    factor = np.sqrt(2)
    if n == 2:
        return np.array([[1, 1], [1, -1]], dtype=float) / factor
    else:
        H_n2 = haar_matrix(n // 2)  # Рекурсия: строим H_(n/2)
        upper = np.kron(H_n2, [1, 1]) / factor  # Верхняя половина
        lower = np.kron(np.eye(n // 2), [1, -1]) / factor
        return np.vstack([upper, lower])  # Собираем H_n

H8 = haar_matrix(8)

A = np.array([
    [188, 174, 165, 174, 160, 152, 148, 150],
    [192, 179, 169, 182, 168, 161, 159, 162],
    [210, 181, 169, 189, 176, 170, 168, 170],
    [198, 182, 180, 194, 184, 180, 178, 179],
    [196, 184, 176, 188, 172, 166, 164, 165],
    [202, 186, 181, 190, 180, 175, 172, 173],
    [216, 190, 185, 195, 190, 185, 182, 183],
    [208, 192, 189, 198, 196, 192, 190, 191]
], dtype=float)

H2D = H8.T @ A @ H8
# Обратное преобразование
A_back = H8 @ H2D @ H8.T

print("Исходная матрица A:")
print(A)
print("\nВосстановленная матрица A_back:")
print(np.round(A_back, 6))
print("\nМаксимальная абсолютная разница:")
print(np.max(np.abs(A - A_back)))

## TODO: добавить padding для случаев когда матрица не 2^k